Client Server Architecture
=============================
Q.With respect to web applications, what exactly is the C-S architecture required?
See below image and explanations for clarity:

Client - Browser
Container
----------
In the differences between web applications and distributed applications, we learn't that web applications are executed by servers-Web servers||Application Servers-in general.
Inside the Server, who is taking responsibility of executing the web application?
The answer is: Containers.
It is inside this Container that our web application is deployed.
Inside the web application; web resources are existed: these maybe;
  -Servlet components
  -JSPs
  -EJB components
  -anything. Some Server side components we can say.
These resources are what is going to be executed at server machine.

Internet
---------
Between client and server we have the internet||network.
Even though internet||network is available, we require protocol for communication- to transfer data from one machine to another machine.

Like this from the briefs above on C-S architecture; 3 main components||parts we have:
  - Client
  - Protocal.
  - Server.

Client
-------
Client-Not a computer.
Client- Is a Browser and strictly speaking; Browser is not even the real Client. haha
A tab inside the browser is what we refer to as the client.
Q. If you open for example 3||n tabs on a browser on a computer; i.e;
 - www.facebook.com
 - www.gmail.com
 - www.get_tt_right.com
 - ...etc.
You will notice that, we are using mutiple tabs on a single browser which is available on a single computer.
From these 3 tabs, we are submitting request to 3 servers. Could be at a single time or one after another; whatever it maybe.
The 3 servers here are:
  - facebook server.
  - gmail server.
  - get_tt_right server.
  - ..etc

Respective servers will take the respective request, process that request and generate some response.
Q. All the 3 responses coming to single client or multiple clients?
Ans.Simple!, 3 different clients. Hence, each and every tab on a browser is the client.

Q. Role of Client in C-S application?
Ans. - Sending request to server.
     - Recieving response from server.

Q. How is a tab in a browser-Client- able to send request to the server?
Ans. By providing a String specification on client address bar.

- This String specification can be used to submit request to the server.
- This String specification is what we refer to as URI-Uniform Resource Identifier.
- Two types of URIs are available:
    -URN:
    -URL:
Q. What is the difference between URI, URN and URL? 
Ans. - At Server side, we are going to write Servelets or not? Yes!! we are...
     - If you want to access that servlet from client; then that servlet requires some identity for sure. Some identity it has to have.
- Two types of identities are availble for the Server side component.
   => Logical name
   => Locator/URL Pattern/ Alias Name
- URI: A string specification provided at client address bar, it can be used to refer to a particular server side resource from client.
- URN: A string specification provided at cleint address bar, it can be used to refer to a particular server side resource through its logical name.
Note: In case of servlets, logical name is a name which we are specifying along with <servlet-name> tag in web.xml
- URL: A string specification provided at client address bar, it can be used to refer to aparticular resource at server machine through its Locator or  Url pattern or alias name.
Note: In case of servlets, locator is a name which is specified along with <url-pattern> tag in web.xml file.

Note: Almost all the servers are supporting URL notation only, no server is supporting URN notation.

URL Syntax:
------------

Protocol
----------------

In web applications, we need a protocol which must be:
1. Connectionless protocol.
  - Should not have any physical||wired connection.
  - The connection should be logical||wireless.
Reason: We don't know where server is located or where our clients are located.

2. Stateless protocol
  - Should only remember current client requet data only and not previous client request data. 

Reason: If it tries to remember previous client request data, protocol may loose its memory size. Whenever the data is exceeded; present request data may not be possible to remember, hence it may not be able to transfer present request data from client to server.

3. Compatible protocol with hypertext data.
  - Generally, in web applications;request data is transferred in the form of Hypertext data-HTML. In some situations also, response data is comming the form of HTML. This is in general.
Thus the compatible protocol for our HTML data is; HTTP.

In a nut-shell, HTTP protocol is having all the above features.

Q. How is HTTP protocol able to manage its stateless nature?
----------------------------------------------------------------
Ans:

- We will use an image for clarity.
- We have Client and Server. 
- Between Client and Server we have a protocol.
- When we submit request from client to server, protocol will carry that and deliver to the destination. Steps:
+. Protocol takes the request.
+. Establish a virtual socket connection between client and server as per the URL what we specified in the Client-Browser tab-that is a per the Server machine Ip address and as per the port number to the server process; automatically a connection will be established between client and server.
+. Prepare a Request Format; inside this, two parts are available:
    1. Header Part
       - Manage request header's data.
       - Request header's data is nothing but: Clients meta data
    2. Body Part
+.

===========================================================================

- Inside Response format header part, a number of fields are available; the first field is: Status Line Field
- In this SLF, server will provide one number: A 3 digit number it will provide.
- This 3 digit number is representaing what is the status of the present request process. Like that request is processed successfully or not.
- If successfully processed, then success related number will be submitted to the client.
- If any error is available at server side, server side related error will be submitted to the client.
- If arror is vailable with request,like; requets is not proper, then client side error-that response will be given to the respective client.
- For example we submitted request to one resource at server side but the required service is not available and now we are re-directing our request to some other application. Like we are under re-direction. This information must be provided to the client.
- To specify either of these statuses to the respective client; in the Response header part we are having a field: Status line Field->A 3 digit number it will provide.
- Once the Response format arrives at client side; first; the Status Line Field will be checked by client.
- The 3 digit number in SLF will be cross-checked and it will tell what is it's status. The status may be:
  +. Success related.--> Means informational response we have recieved.
    - Actual response data from the body part will be displayed.
  +. Error related response.
    - If this is coming, it will prepare an error message in it own way and proceed to displaying that error message on our browser.
 +. Redirectional response. 
   - Will get a new URL and like this second request will be submitted to the new URL.

The 3 digit number provided in the SLF of Response format header part is what we refer to as the Status code.

- For these status codes, we are not going to do anything; internaly server and protocol will manage that staus codes and protocol will submit that status related  data to the respective client which will be able to tell what to do on cros-checking tht status code that is available in the SLF of Response format header part.

- HTTP Protocol has given support for status codes,what exactly are the status codes provided||supported by HTTP protocol?
- They are given in categorization:
1. 1XX----> 100 to 199 ---> Informational Satus codes.
  - Normal information the will give.
2. 2XX ---> 200 to 299 ---> Success related status codes.
3. 3XX ---> 300 to 399 ---> Redirectional status codes.
4. 4XX ---> 400 to 499 ---> Client side etrrors status codes.
5. 5XX ---> 500 to 599 ---> Server side errors status codes.

That was the minimum content you are required to know about protocol.
Next, we are going to understand out the server part.

Server
-------
It is a special software installed in server machine.
It will perform the following actions in C-S appliactaions:
- Takes reqest from Protocol.
- Identifies the requested resource at server side application.
- Executes the server side application's resource
- Generates response to protocol.
Example s of servers available in the market:
- Tomcat
- Weblogic
- JBOSS
- Wildfly
- Glassfish.
- ...

Servers are divided into two types:
- Web servers
- Application Servers

Q. What are the diffrences between Web Servers and Application Servers?
-------------------------------------------------------------------------
Ans:
-----
1. Web servers are able to provide environment to design and excute web applictations only.
   Application servers are providing environment to design and excute both web applications and distributed applications.

2. To prepare distributed applications, we need some middleware services. In general, these middleware services include:
   +. JNDI --> Java Naming and Directory Interface.
   +. JTA --> Java Transaction API.
   +. JMS --> Java Messaging Service.
   +. JCA --> Java connector Arcgitecture.
   +. JAAS --> Java Authentication and Authorization Service.
   +. ...etc
All these middleware services are required to prepare distributed applications.
These middleware services are provided by application servers by default and are not provided by web servers.

In a nut-shell: Web servers are not providing middleware services like JNDI,JTA, JAAS, JMS, ...
Application Servers are providing middleware services like JNDI, JTA, JAAS, JMS,... by default


In the initial stages of Computer Science and in the initial stages of C-S architecture; web-servers main intention is: web applications.
Web applications main intention is: static response. 2 to 3 pages are available; from one page to another page we want to navigate and for that particular reason only we are using web-servers.
Application servers on the other hand are mainly for dynamic response.
Later on, this requirement has changed: From web applications we are also expecting dynamic response and in distributed applications, along with web applications, some distributed environment also we are expecting.


When I install server software on server machine: two modules are installed:
1. Main Server
2. Container

Q. What is the difference between Main Server and Conatiner.
------------------------------------------------------------
Ans.
----
We are going to see an image below for clarity:
- In the address bar at Client side, I provided the URL: http://localhost:8080/app1/res1
- On clicking the enter button, request will come to protocol.
- Protocol will establish a virtual socket connection between cleint and server based on ip address and port number information available in the URL.
- Protocol will prepare Request Format.
- It will carry the Request format to the Server Merchine.
- At Server machine two components are available; Main Server and Container.
- Main Server will take the responsibility to recieve the Request Format from protocol.
- Main Server will go ahead and:
+. Check whether the incoming request is good or not.
+. If everything inside the incoming request is not proper and some issues are their in the request such that it is not in a proper format, main server will send some response to the client which says: Bad request.
+. If the request is proper: Good request, it will identify for which resource is this request coming for. i.e., 
  1. Is this request coming for html resource
  2. Is this request coming for a Servlet or JSP resource.

- If the request is coming for a static resource i.e., html page, then it will take a copy of that resource and send that as a response to the respective client.
- If request is coming for a resource that needs to be executed at server side i.e., a Servlet, then only, Main server will pass that request to Container.
- You may have a question like, why is it that for executable resources such as Servlets, Main server is forwarding that request to the Container and not handling that by itself?
Ans:
----
- Actaully Server side components are excecuted by folloeing lifecycle actions.
- How to excecute servlets? By following lifecyle actions. Which lifecycle actions?
- It's only Container that has knowledge of what lifecycle actions need to be followed while executing a server-side resource.
- Main Server is not aware of the lifecyle actions that need to be followed while execeuting the serverside component.
- So how to execute a server side component like; servlet is known by the Container only, not known by the Main server.
- Main server will have knowledge that the incoming request is for a servlet resource, but, I don't know haow to execute that resource!, what will I do?
- The obvious solution is to forward that request to the person-Container- who knows how to execute that Servlet.

- In a nut-shell; Container will execute dynamic resources i.e., Servlets.
  Main Server will copy static resources and give that as response to client of an incoming request is for the static resource.
- Moreover, dynamic resources i.e., Servlets are executed by following Lifecycle actions. That lifecycle actions implementations are available with the Container only.
 Lifecycle implementations are not available with Main Server.

Servlet API is managed by Container only, it is not managed by Main server.
- Once this incoming request for a dynamic resource i.e., Servlet is forwarded by the Main Server to the Container; Immediately, Container will recognize for which application the request is coming, this it will tell from the URL. i.e., app1
- If app1 is available, Container will take the resource name/path whatever we are requesting and it will cross-check if that is available inside app1.i.e., res1
- If the resource name/path is available, Container will go ahead and execute that resource by following lifecycle actions since it knows how to execute that resource.
- The lifecycle actions for executing a servlet include:
   +. Servlet loading.
   +. Servlet Instantiation.
   +. Servlet Initialization.
   +. Request processing.
   +. Servlet de-instantiation.
- By following these 5 steps, that Servlet will be executed.
- By the execution of this servlet, automatically some response will be generated and whatever response is generated; Container will take that response and it will forward it to MainServer.
- Main server is aware how to dispatch response to client through protocol.
Note: Container responsibility is not to send response to client.

Container responsibility:
--------------------------
- Recieve the incoming dynamic resource request from Main server.
- Identify the dynamic resource. i.e., servlet.
- Execute the resource.
- Give dynamic response back to Main Server.

Main Server responsibility:
-----------------------------
- Recieve incoming request for resource from protocol.
- Check if the request is for static resource or dynamic resource.
- If request is for static resource, it will take a copy of that resource and prepare a response format which it will hand over to protocol to carry it to the client.
- If request is for dynamic resource, it will hand over the request to Container.
- The response it will recieve from Container after Container is done with handling the request, it will forward that to protocol.

Protocol responsibility:
----------------------------
- Take request from from Client.
- Establish a virtual socket connection from client to server.
- Prepare Request Format.
- Carry that request to Main Server.
- On reciept of response from main server, it will prepare repsonse format.
- Carry the response format back to client.

Client responsibility:
-----------------------
- Submit request to protocol.
- Recieve the response from protocol and based on the receipt response take the necessary action based on the status code in the SLF of response format header part.

Example of Static related contents:
- Main server will handle incoming request for static related contents.
+. HTML pages. 
+. Images.
+. ...etc

Example of dynamic related contents:
+. EJB's  - Executed by EJB Container.
+. Servelets - Executed by Servelt Container.
+. JSP's - Executed by JSP container.
+. ...etc

Classification of Containers.
------------------------------
 1. As per technology used to prepare applications.
    - There are 2 types of Containers:
      1. Web Container.
      =================
- Able to execute only web resources. Examples of these web resources includes:
 +. Servlets
 +. JSPs
- These Web Containers are classified into two types again:
 +. Servlet Container
 +. JSP Container.
      2. EJB Container.
      ==================
- Able to execute EJB components only.

When you are using JMS, JMS Container also you will find. In a nut-shell we can conclude that multiple containers are existed based on the technology you are using to prepare your application.

2. As per the physical existnace of the Container with main server.
- There are three types of Containers here:
   1. Standalone Container.
   ===========================
- It is an Integration of Main server and Container as a single unit. They are existed as a single program.
- Like same program is acting as Main server as well as Container.
   2. In process Container.
   ===========================
-  Exists inside Main server. Nothing but, it is a part inside main server. As a sub-process inside main server it is running.

   3. Out of Process Container.
   =============================
- Exists completely outside of the Main Server.

Dependent on the Server software we are going to install on our machine, the type of Container it will come with may vary.

That was it about Servers.

Steps to prepare Web applications
===================================
1. Download and Install Tomcat Server.
2. Prepare Web application directory structure at Server.
3. Prepare deployment descriptor[web.xml file].
4. Prepare Web resources like Servlets.
5. Start Server and access web application.

1. Download and Install Tomcat Server.
------------------------------------------
- To check if Tomcat is installed or not:
Control Panel --> Programs --> Programs and features --> Serch for Tomcat

+. Tomcat download.
+. Download installer and install(Recommended).
   - Do not download the zip file.
   - If you already have Oracle installed in your machine, then by deafult it already taken port number 8080.
   - So, you will have to change. i.e., to 1010
   - Else, port clashing.
+. 
2. Prepare Web application directory structure at Server.
=============================================================
- We are going to see an image for clarity.
- Under folder structure we have one installation folder: C:\Program Files\Apache Software Foundation\Tomcat 10.1
- Inside this folder, anumber of subfolders are existed:
   +. bin folder
    ==============
   - Contains: 
      .bat files
      .exe files
   - The purpose of these files is: To start server and to shutdown server.
   - To start Tomcat server go to bin-> Tomcat10 application with the description; `Apache Commons Daemon Service Runner`  is available.
   - Double click on this application to start. Some CUI window will open.
   - To stop the server; just close CUI window.
   - As an alternative we also have startup.bat and shutdown.bat to start and shutdown the server respectively.
   +. conf folder
    ==================
   - Contains .xml files. Ex's:
     1. tomcat-users.xml file
        -----------------------
      - To get and even modify some of the details partaining pwd and username.
     2. server.xml file
       ------------------------
      - To get and even modify some of the details about our Tomcat server.
     3. ...etc
  +. lib folder.
   =============
 - Contains .jar files wich are required by Tomcat server. Ex's
 - .jar files in the sense;
     => servlet library related jar files.
     => JSP library related jar files.
     =>  ...etc
- In future, when I prepare my Servlet class, and when I want to comiple it, then I need to set class path to these jar files.

+. logs folder.
   =============
Purpose:-
- Server started, Server shutted down, Server application deployed, ...etc; these kind of statuses we are able to get in the form of logs.
- Depending on our servers, .txt or .log files you will find them in this folder.
- Status about our server software and server applications we are able to get in log files present in this folder.

+. temp folder.
   =============
- Able to manage any tempory files if they are exeisted.

+. work folder.
   =============
- Its purpose is: Maintaining internal processing of our server applications. 
- For example I prepared a JSP page and am submitting request for this JSP page
  => JSP page is excuting now.
  => How is it running actually? 
    . It is converted to Servlet-Servlet.java files and Servlet.class files- and Servlet will be executed internally.     
    . By the execution of this servlet; some response we are getting now.
- The point is; internally a Servlet is created-Servlet.java files and Servlet.class files.
- Where are these Servlet.java and .class files going to be maintained? Inside this work folder.
- Whatever the web application(s) we prepared with Tomcat server all these things are going to be maintained under work folder. Nothing but, a duplicate application will be created under work folder and there only this internal processing will be performed.
- work folder purpose is for internal processing of our web application(s).

+. webapps folder.
   ================
-  We are going to prepare our applications in this folder, then only:
   . Server will be able to recognize||idendify, deploy our application(s) into server space and finally it can be able to execute our application(s).
Steps:
-------
=> Create your application folder. i.e., bankapp
=> Under application folder a number of sub-folders we need to prepare: They generally include:
   themes folder--> .css files,...etc
   images folder --> .jpg, png files, ...etc
   literature folder --> .doc
       - If you want to prepare documentation about your application, the documentation you can maintain under literature folder.
   src folder --> .java files go in this folder.
   .html files, .html files  --> You could place them in a folder or just mainatain them as files singly inside application folder. This applies to all other file types we've discussed previously i.e., .css files, image files, literature files, etc.
- Along with the files and folders we've seen above that are going into application folder, one more mandatory sub-folder of application folder we need to prepare, that is: WEB-INF
This means nothing but under this folder our web application information we need to provide||maintain here.
- Under WEB-INF folder, other sub-folders are available:
   lib folder: has .jar files which are required for our web application.
     For example, to prepare:
     +. JDBC application--> ojdbc .jar file I need.
     +. etc
   web.xml file: Is our deployment descriptor.
   - Our Servlet configurations, filters configurations, + a number of other resources configurations we are going to maintain them inside this folder by making use of xml tags.
   classes folder: All the .class files are going to be maintained here. i.e., Servlet.class files, Filters.class files, ...etc
     
- All these folders are coming with our Tomcat server during installation. We are not going to create any of the above folders.
- Some of the folders inside the application folder we are going to create.
In a nutshell:
The total directory structure is divided into 2 parts:
 +. Public Area/Client Area.
- Area outside the WEB-INF folder and inside the application folder.
- If we keep any resource under public area then we are able to access that resource from client by using the respective resource name directly.
In general, we keep: html files under application folder. To access these html files we will directly use html file name.
   http://locolhost:8080/loginapp/loginform.html
 +. Private Area/Server Area.
- Area inside the WEB-INF folder.
- If we keep any resource under private area then we are unable to access that resource by using its name directly, we are able to access that resource through its alias name which we have declared in web.xml file.

Under classes         mapping inside web.xml file
   LoginServlet <---> /login
http://locolhost:8080/loginapp/loginServlet.class --> Invalid way of accessing this resource.
http://locolhost:8080/loginapp/login  --> Valid way to access this resource


3. Prepare deployment descriptor[web.xml file].
- Deployment descriptor is web.xml file.
- It will provide description/metadata i.e., alias names, ...etc about our application which is required by the Container in order to identify and excute server side resources.
- In web applications, what are the responsibilities of web.xml file:
  +. Welcome files configurations
  +. Display names configuration.
  +. Servlet configurations
  +. Filters configuration
  +. Listeners configurations
  +. Initialization parameters configurations
  +. Context parameters configurations
  +. Error pages configurations.
  +. Session Time out Conf
  +. Security conf
  +. Taglib configurations.
  +. ...etc

Servlet configurations:
-------------------------
- Servlet classes will be kept in general in private area-inside WEB-INF folder under the sub-folder classes.
- Since we are unable to access servlets by using there names directly from client, we have to define alias names for these servlets and by using that alias name only we are able to acces that servlets.
- In web applications to define alisas names and provide mapping between alias names and servlet class names we have to use "Servlet Configuration" in web.xml file
- To provide servlet configurations in web-xml file we have to use the following xml tags:
   <web-app>
    ---------
    ---------
    ---------
   </web-ap>
It is the root tag and it is representing one application data.
Inside it a number of tags are available.

  <servelet></servlet>
  <servlet-mapping></servlet-mapping>

Under <servelet></servlet> two tags we have to provide

   <servlet-name>Logical name</servlet-name>
   <servlet-class> Fully qualified name of the servlet class</servlet-class>

Under <servlet-mapping></servlet-mapping>vtwo tags we have to provide

   <servlet-name>Logical name</servlet-name>
   <url-pattern>/patternName</url-pattern>
This pattern name is also known as: alias name||locator.

Ex:
 <web-app>

   <servlet>
      <servlet-name>loginServlet</servlet-name>
      <servlet-class>com.csm.servlets.LoginServlet</servlet-class>
   </servlet>

   <servlet-mapping>
      <servlet-name>logiServlet</servlet-name>
      <url-pattern>/login</url-pattern>
   </servlet-mapping>  

 </web-app>

 URL Patterns definitions:
 ---------------------------
- In web applications, we are generaly able to define URL patterns in 3 ways:
  +. Exact match method
  +. Directory match method.
  +. Extension match method.

+. Exact match method
-----------------------------
We will define a url pattern in web.xml file, it must start with /
Ex:
<url-pattern>/abc/xyz</url-pattern>

To access the respective Servlet class,url pattern provided at client address bar must be same as the URL patttern what we defined in web.xml file.Else invalid.

http://locolhost:8080/app1/abc/xyz  --> Valid
http://locolhost:8080/app1/abc  --> Invalid
http://locolhost:8080/app1/xyz  --> Invalid
http://locolhost:8080/app1/xyz/abc -->Invalid

In web applications when we want to access servelets individually, there we will use exact match method to define URL pattern.

 +. Directory match method.
--------------------------------
- We will define url pattern in web.xml file, it must start with / and it must be ended with *
Ex:
<url-pattern>/abc/*</url-pattern>

 +. Extension Match Method:
----------------------------
We will define URL pattern in web.xml, it may start with * but it must be ended with a particular extension.
EX:
<url-pattern>*.do</url-pattern>
Q. How will it be possible to access the respective server side resource now?
Ans. 
- If you want to access the respective Server side resource then the url pattern we specify at client address bar can start with anythin but it must end with the extension which we provided in url pattern specified in web.xml.
Ex: http:locolhost:8080/app1/login.do --> Valid
         locolhost:8080/app1/reg.do   --> Valid
         locolhost:8080/app1/add.do   --> Valid
         locolhost:8080/app1/search.do --> Valid
         locolhost:8080/app1/update.abc --> Not Valid
         locolhost:8080/app1/delete.do  --> Valid

Generally, in MVC based web applications, a servlet will be used as Controller; the respnsibilty of the Controller thus is:
 - Take all request from client and perform actions on the basis of the specified URL pattern.
In this Context, we will use extension match method to define URL pattern for the Controller servlet.

Example:
-------
- Some modules/actions/models I have: add, search, delete, ...etc => Present in business layer.
- Controller I have
- Some Views I also have i.e 
  +.View to create or add a Student
     http://locolhost:8080/app1/add.do
  +.View to search for a Student
     http://locolhost:8080/app1/search.do
  +.View to delete a Student.
     http://locolhost:8080/app1/delete.do
- From the form/view, url pattern will come.
- Url pattern for Controller is *.do
- For the model layer components, they represent some action classes where some logic is available.
- Clicking on the add button of addform.html, request will come to Controller component.
- Container will take that URL pattern name: add.do
- Container will proceed to comparing add.do and *.do, yes! they are the same.
- Controller will remove the .do extention
- Immediately Controller will invoke the add action.
  action name and respective url pattern name must be the the same

- Clicking on the search button of searchform.html, request will come to Controller component.
- Container will take that URL pattern name: search.do
- Container will proceed to comparing search.do and *.do, yes! they are the same.
- Controller will remove the .do extention
- Immediately Controller will invoke the search action.
  action name and respective url pattern name must be the the same

- Clicking on the delete button of searchform.html, request will come to Controller component.
- Container will take that URL pattern name: delete.do
- Container will proceed to comparing delete.do and *.do, yes! they are the same.
- Controller will remove the .do extention
- Immediately Controller will invoke the delete action.
  action name and respective url pattern name must be the the same

In MVC application, extention match method is used frequently.


4. Prepare Web resources like Servlets.
------------------------------------------
- Servlet: It is a server side component managed by Container, by the execution servlet,container will generate dynamic response from server to client.
  In general most people are thinking that; Servlets are generating dynamic response to the client; No! A Servlet is a program available at Server machine, that's it. Container has to execute that program then only it-Container- will response will be generated to the client

- Servlet is a server side program, it must implement javax.servlet.Servlet interface either directly or indirectly.
- To prepare Servlets, Servlet API has provided predefined library in the form of javax.servlet package and javax.servlet.http package.
- Below is the directory structure of the predefine library provided to prepare Servlets.


Q. What are the various approaches to prepare Servlets as per the predefine library provided by Servlet API?
--------------------------------------------------------------------------------------------------------------
Ans.  3 approaches are available.
1. By implementing servlet Interface
2. By extending GenericServlet abstract class.
3. By Extending HttpServlet abstract class.

1. By implementing servlet Interface
---------------------------------------
- public class MyServlet implements javax.servlet.Servlet{
         //Impl all methods of Servlet interface
   }

2. By extending GenericServlet abstract class.
-----------------------------------------------
- public class MyServlet extends GenericServlet{
        // implementation for all service provided methods. 
    }
- Inside this GenericServlet, their is a method like service() Method.
- In this service() method only we have to provide implementation part.

3. By Extending HttpServlet abstract class.
-----------------------------------------------
public class MyServlet extends HttpServlet{
     // impl for service provided methods
   }
- 


5. Start Server and access web application.
-----------------------------------------------








Servlets Design
--------------------
- In 3 ways we are able to prepare servlets:
1. By implementing Servlet interface
2. By extending GenericServlet abstract class.
3. By extending HttpServlet abstract class.

1. By implementing Servlet interface
---------------------------------------
- How many methods are available inside; Servlet interface and what is the purpose of each and every method.
 +. Overall 5 methods are available;
   1. init() method
     - Executed when Container is performing Servlet initialization phase.
     - Servlet initialization is performed by Container not init method.
     - Inside init method, we can write our logic that we need to be excuted by Container as part of servlet initialization phase.
Ex: I want to travell to Mt.View
    I will go at the bus stage to wait for a bus
    When bus is coming then only we will board it.
    By you waiting at the bus stage is not the reason why a bus you will board is passing by to pick you.
    If you we'rent present the bus would still pass.
Container is available, inside Container 10's of thousand of lines are availble for implementing Servlet life cycle. 

For Servlet loading - some 1k+ lines of code
Servlet instantiation - some 1k+ lines of code
Servlet initialization - some 1k+ lines of code
...etc

When request is coming to the Container, Container will start Servlet lifecycle actions
As part of Servlet loading phase some actions/methods will be invoked
As part of Servlet instantiation phase some actions/methods will be invoked
As part of Servlet initialization phase some actions/methods will be invoked. i.e., init() method
As part of Servlet request processing phase some actions/methods will be invokedy. i.e, service() method

Like this, these methods() are called while performing Servlet lifecycle actions by the Container. Container is having a program to perform the lifecycle actions and as part of that, it will call the methods we are are discussing here.

Like the methods we are discussing here are not the reason as to why Servlet lifecycle actions are executed. Relate that with the leimans example of bus I have just discussed above.

   2. service() method
     - It is like main method in core Java program. Why are we providing main method in core Java applications? Ans. To provide our application logic. This method has to be recognized and executed by the JVM automatically.
     - Application logic we need to keep here in the case of our Servlets just like main method. If we keep application logic here, when we submit request from client to server; server will come to service() method and will executed whatever logic is present here.
 - Like this, service() method is like main() method in or core Java application.
     - Executed while performing request processing by Container.
- How do we implement service() method; some few steps we will see later.
   3. getServletConfig() method
- We know that, container will call inti() method while performing Servlet initialization.
- When Container is calling this init() method, it must create ServletConfig object.
- Container must pass that ServletConfig object reference as a parameter to init() method.
- ServletConfig object contains the configurationdetails of the Servlet. i.e.,
   +. Logical name of the Servlet
   +. Initialization parameters of the Servlet.
   +. ...etc
- Now, whatever the ServletConfig object which is created and passed inside init() method as a parameter by the Container; that object I want to get it.
- To get this generated ServletConfig object, we have to use; getServletConfig() method.
- Used to return the generated ServletConfig object.
   4. getServletInfo() method
     - To return||get metadata||some description about our Servlet.
   5. destroy() method.
     - Executed as part of Servlet de-instantiation phase.
- Remember: Their is implementation inside Container for de-instantiation
- When Servlet de-instantiation is performed by the Container, then; automatically this destroy() method will be excuted.

public class MyServlet implements Servlet
{
  // Implementaion for all methods of Servlet interface with or without the requirement. Else you will get Compilation error.
}

Servlet interface
---------------------
public interface Servlet{
   public void init(ServletConfig config)throws ServletException;  // Executed a s part of the Servlet initialization phase. It is a lifecycle method.
   public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; // Executed while performing the request processing phase of the Servlet lifecycle. It is a lifecycle phase.
   public ServletConfig getServletConfig(); // Just a normal method to return||get ServletConfig object.
   public String getServletInfo(); // Normal methos to return the metadata of the respective servlet.
   public void destroy(); // It is a lifecycle method executed as part of the servlet de-instantiation phase.

}
- Those were the methods we need to write in order to prepare our Servlets in the case where our Servlet class implements Servlet interface.
- All the methods above, are not doing any activities of Servlet life cycle. Container is having clear-cut implementation on Servlet life cycle and as part of the Servlet life cycle container will inly but invoke these methods i.e., init(), service(), destroy(), ...
Ex:
- Container is performing Servlet initialization and as part of this Servlet initialization, if you want to execute something as part of Servlet initialization phase, then Servlet has given an option for us;  provide init() method and inside this init() method we can keep some logic which is going to be excuted as part of the servlet initialization phase.

 Of 5 methods available inside the Servlet interface, 3 methods are involved Servlet lifecyle.
  - init() method
  - service() method
  - destroy() method.

The rest two methods are non-lifecycle methods.
  - ServletConfig()
  - getServletInfo()
They will not be involved in the lifecycle of the respective Servlet action.



1. service() method.
-------------------
- We are going to provide our actual application logic here.
- Mandatory to implement this method.
- In Container, Servlet lifecycle as per the request processing phase; service() method will be executed.
- This is like main method in our core java program.
- When you submit request from Client to Server, Container will come to our Servlet, execute service() method as part of the request processing phase. 
- By the excution of service() method, then response will generated to the respective client.
- How to implement service() method.
- Below is the complete prototype of service() method.

Skeleton||prototype
--------------------
public void service(ServletReqiest req, ServletResponse res) throws ServletException, IOException
  {


  }

- Whatever data that is coming from request, that is available in requestformat that will come into: ServletRequest parameter.
- ServletRequest object, rq , is able to provide the complete information about our request.
- It is through this parameter that requestformat data will be injected into our service() method.
- From this, ServletRequest object-rq- we are able to access the request data whatever is coming from client.
- At the time of calling service() method both ServletRequest object and ServletResponse object are created.
- In ServletRequest object, incoming request data is stored but at the time of calling service() method, ServletResponse object is an empty object.
- When Container executes whatever logic is available inside service() method, dynamic response will be generated which will now go and get stored in ServletResponse object.
- Container will take the dynamic response from ServletResponse object and dispatch that back to the client.
- Developer job when it comes matters service() method is;
   => Get some input data from ServletRequest object.
   => Use that data in application logic||prapare application logic.
   => Prepare some dynamic response
   => Give that dynamic Response to ServletResponse object.
- When we keep the dynamic response in ServletResponse object, Container is responsible to get the response from here and then submit that response data to the respective client.
- How to dispatch response to the Client, Container and server will take care of that. This won't be our concern!
- How to get data from ServletRequest object, we will get to know about this later.
- How to keep some response in ServletResponse object, then we will follow the below steps;

1. Set Response Type to the response object.
- Means: which type of response we need to generate from this Servlet, that we have to set.
   res.setContentType("text/html")
- If you set the response type to text/html, means text||html kind of data will be stored in ResponseFormat header part.
 Note: The default content type in Servlets is "text/html" only.

2. get PrintWriter object.
   PrintWriter out = res.getWriter();

3. Send response data to Response object.
   out.println("<html>");
   out.println("<body>");
   out.println("Welcome To Servlets");
   out.println("</body>");
   out.println("</html>");

Above are the 3 steps to prepare service method.


Preparing first Servlet application.
--------------------------------------
Inside webapps folder; I need to prepare my Servlet applications as below:

<web-app>
  <servlet>
     <servlet-name>WelcomeServlet</servlet-name>
     <servlet-class>WelcomeServlet</servlet-class>
  </servlet>
    
  <servlet-mapping>
    <servlet-name>WelcomeServlet</servlet-name>
    <url-pattern>/welcome</url-pattern>
  </servlet-mapping>
<web-app>

import javax.servlet.*;
import java.io.*;

public class WelcomeServlet implements Servlet
{
// main() method should not be provided. As Container will take care of managing Servlet lifecycle

//init() method
   public void init(ServletConfig config) throws ServletException
   {
   }
//service() method
  public void service(ServletRequest, ServletResponse)throws ServletException, IOException
   {
     response.setContentType("text/html");
     PrintWriter out = response.getWriter();

     out.println("<html>");
     out.println("<body>");
     out.println("<h2>");
     out.println("<font color='red'>");
     out.println("<b>");
     out.println("Welcome to get_tt_right.com");
     out.println("</b><hr></font></h2></body></html>");
   }
// getServletConfig method
  public ServletConfig getServletConfig()
  {
     return null;
  }
// getServletInfo method
  public String getServletInfo()
  {
    return "";
  }

// destroy method
  public void destroy()
  {
   
  }
  
}





















How to make github as default editor for git bash instead of VI
--------------------------------------------------------------------
git config --global core.editor "code --wait"





